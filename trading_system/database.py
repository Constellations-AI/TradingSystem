"""
SQLite Database Manager for Trading System
Handles all database operations including caching, briefings, and analytics
"""
import sqlite3
import json
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from contextlib import contextmanager
import os


class Database:
    """Central database manager for trading system data"""
    
    def __init__(self, db_path: str = "trading_system.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize database with required tables"""
        with self.get_connection() as conn:
            # Raw API calls and responses
            conn.execute("""
                CREATE TABLE IF NOT EXISTS raw_api_calls (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    provider TEXT NOT NULL,  -- 'alpha_vantage', 'polygon'
                    function_name TEXT NOT NULL,  -- 'NEWS_SENTIMENT', 'SYMBOL_SEARCH'
                    parameters TEXT NOT NULL,  -- JSON string of parameters
                    parameters_hash TEXT NOT NULL,  -- Hash for quick lookup
                    response_data TEXT NOT NULL,  -- JSON response
                    success BOOLEAN NOT NULL,
                    error_message TEXT,
                    was_cached BOOLEAN DEFAULT FALSE,
                    cache_age_seconds INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(provider, function_name, parameters_hash)
                )
            """)
            
            # Market briefings generated by intelligence agent
            conn.execute("""
                CREATE TABLE IF NOT EXISTS market_briefings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_id TEXT NOT NULL,
                    user_query TEXT NOT NULL,
                    success_criteria TEXT NOT NULL,
                    briefing_content TEXT NOT NULL,
                    agent_type TEXT DEFAULT 'market_intelligence',
                    processing_time_ms INTEGER,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Junction table linking briefings to their data sources
            conn.execute("""
                CREATE TABLE IF NOT EXISTS briefing_data_sources (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    briefing_id INTEGER NOT NULL,
                    api_call_id INTEGER NOT NULL,
                    data_freshness_seconds INTEGER NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (briefing_id) REFERENCES market_briefings (id),
                    FOREIGN KEY (api_call_id) REFERENCES raw_api_calls (id)
                )
            """)
            
            # User sessions and conversation history
            conn.execute("""
                CREATE TABLE IF NOT EXISTS user_sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_id TEXT UNIQUE NOT NULL,
                    user_query TEXT NOT NULL,
                    success_criteria TEXT NOT NULL,
                    conversation_history TEXT,  -- JSON array of messages
                    debug_mode BOOLEAN DEFAULT FALSE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Evaluator feedback and decisions
            conn.execute("""
                CREATE TABLE IF NOT EXISTS evaluator_feedback (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_id TEXT NOT NULL,
                    briefing_id INTEGER,
                    feedback_text TEXT NOT NULL,
                    success_criteria_met BOOLEAN NOT NULL,
                    user_input_needed BOOLEAN NOT NULL,
                    evaluation_reasoning TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (briefing_id) REFERENCES market_briefings (id)
                )
            """)
            
            # Tool usage tracking
            conn.execute("""
                CREATE TABLE IF NOT EXISTS tool_usage (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_id TEXT NOT NULL,
                    tool_name TEXT NOT NULL,
                    tool_args TEXT NOT NULL,  -- JSON string
                    tool_response TEXT NOT NULL,
                    execution_time_ms INTEGER,
                    success BOOLEAN NOT NULL,
                    error_message TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Create indexes for performance
            conn.execute("CREATE INDEX IF NOT EXISTS idx_api_calls_hash ON raw_api_calls (provider, function_name, parameters_hash)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_api_calls_created ON raw_api_calls (created_at)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_briefings_session ON market_briefings (session_id)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_sessions_id ON user_sessions (session_id)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_tool_usage_session ON tool_usage (session_id)")
            
            conn.commit()
    
    @contextmanager
    def get_connection(self):
        """Context manager for database connections"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # Enable dict-like access
        try:
            yield conn
        finally:
            conn.close()
    
    def generate_params_hash(self, params: Dict[str, Any]) -> str:
        """Generate consistent hash for API parameters"""
        # Sort parameters for consistent hashing
        sorted_params = json.dumps(params, sort_keys=True)
        return hashlib.md5(sorted_params.encode()).hexdigest()
    
    def check_api_cache(self, provider: str, function_name: str, params: Dict[str, Any], 
                       cache_ttl_seconds: int = 1800) -> Optional[Tuple[Dict, int, int]]:
        """
        Check if API call exists in cache
        Returns: (response_data, cache_age_seconds, api_call_id) or None
        """
        params_hash = self.generate_params_hash(params)
        cutoff_time = datetime.now() - timedelta(seconds=cache_ttl_seconds)
        
        with self.get_connection() as conn:
            result = conn.execute("""
                SELECT id, response_data, created_at FROM raw_api_calls
                WHERE provider = ? AND function_name = ? AND parameters_hash = ?
                  AND created_at > ? AND success = TRUE
                ORDER BY created_at DESC LIMIT 1
            """, (provider, function_name, params_hash, cutoff_time)).fetchone()
            
            if result:
                # created_at is stored in UTC 'YYYY-MM-DD HH:MM:SS' format
                created_at = datetime.strptime(result['created_at'], "%Y-%m-%d %H:%M:%S")
                cache_age = int((datetime.utcnow() - created_at).total_seconds())
                response_data = json.loads(result['response_data'])
                return response_data, cache_age, result['id']
        
        return None
    
    def save_api_call(self, provider: str, function_name: str, params: Dict[str, Any],
                     response_data: Dict, success: bool, error_message: str = None,
                     was_cached: bool = False, cache_age: int = 0) -> int:
        """Save API call and response to database"""
        params_hash = self.generate_params_hash(params)
        
        with self.get_connection() as conn:
            try:
                cursor = conn.execute("""
                    INSERT INTO raw_api_calls 
                    (provider, function_name, parameters, parameters_hash, response_data, 
                     success, error_message, was_cached, cache_age_seconds)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    provider, function_name, json.dumps(params), params_hash,
                    json.dumps(response_data), success, error_message, was_cached, cache_age
                ))
                conn.commit()
                return cursor.lastrowid
            except Exception as e:
                # If there's a constraint error, just return a dummy ID and continue
                print(f"⚠️ Database insert warning (continuing): {e}")
                return 1  # Return dummy ID to keep things working
    
    def save_briefing(self, session_id: str, user_query: str, success_criteria: str,
                     briefing_content: str, processing_time_ms: int = None,
                     data_source_ids: List[Tuple[int, int]] = None) -> int:
        """
        Save market briefing and link to data sources
        data_source_ids: List of (api_call_id, freshness_seconds) tuples
        """
        with self.get_connection() as conn:
            # Save briefing
            cursor = conn.execute("""
                INSERT INTO market_briefings 
                (session_id, user_query, success_criteria, briefing_content, processing_time_ms)
                VALUES (?, ?, ?, ?, ?)
            """, (session_id, user_query, success_criteria, briefing_content, processing_time_ms))
            
            briefing_id = cursor.lastrowid
            
            # Link to data sources
            if data_source_ids:
                for api_call_id, freshness_seconds in data_source_ids:
                    conn.execute("""
                        INSERT INTO briefing_data_sources 
                        (briefing_id, api_call_id, data_freshness_seconds)
                        VALUES (?, ?, ?)
                    """, (briefing_id, api_call_id, freshness_seconds))
            
            conn.commit()
            return briefing_id
    
    def save_session(self, session_id: str, user_query: str, success_criteria: str,
                    conversation_history: List[Dict], debug_mode: bool = False):
        """Save or update user session"""
        with self.get_connection() as conn:
            conn.execute("""
                INSERT OR REPLACE INTO user_sessions 
                (session_id, user_query, success_criteria, conversation_history, debug_mode, updated_at)
                VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            """, (session_id, user_query, success_criteria, json.dumps(conversation_history), debug_mode))
            conn.commit()
    
    def save_evaluator_feedback(self, session_id: str, briefing_id: Optional[int],
                               feedback_text: str, success_criteria_met: bool,
                               user_input_needed: bool, reasoning: str = None):
        """Save evaluator feedback"""
        with self.get_connection() as conn:
            conn.execute("""
                INSERT INTO evaluator_feedback 
                (session_id, briefing_id, feedback_text, success_criteria_met, 
                 user_input_needed, evaluation_reasoning)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (session_id, briefing_id, feedback_text, success_criteria_met, 
                  user_input_needed, reasoning))
            conn.commit()
    
    def save_tool_usage(self, session_id: str, tool_name: str, tool_args: Dict,
                       tool_response: str, execution_time_ms: int = None,
                       success: bool = True, error_message: str = None):
        """Save tool usage tracking"""
        with self.get_connection() as conn:
            conn.execute("""
                INSERT INTO tool_usage 
                (session_id, tool_name, tool_args, tool_response, execution_time_ms, success, error_message)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (session_id, tool_name, json.dumps(tool_args), tool_response, 
                  execution_time_ms, success, error_message))
            conn.commit()
    
    def get_briefing_analytics(self) -> Dict[str, Any]:
        """Get analytics on briefing performance"""
        with self.get_connection() as conn:
            # Basic counts
            total_briefings = conn.execute("SELECT COUNT(*) as count FROM market_briefings").fetchone()['count']
            total_api_calls = conn.execute("SELECT COUNT(*) as count FROM raw_api_calls").fetchone()['count']
            cache_hit_rate = conn.execute("""
                SELECT 
                    COUNT(CASE WHEN was_cached THEN 1 END) * 100.0 / COUNT(*) as rate
                FROM raw_api_calls
            """).fetchone()['rate']
            
            # Recent activity
            recent_sessions = conn.execute("""
                SELECT COUNT(DISTINCT session_id) as count FROM user_sessions 
                WHERE created_at > datetime('now', '-24 hours')
            """).fetchone()['count']
            
            return {
                'total_briefings': total_briefings,
                'total_api_calls': total_api_calls,
                'cache_hit_rate': round(cache_hit_rate, 2) if cache_hit_rate else 0,
                'recent_sessions_24h': recent_sessions
            }
